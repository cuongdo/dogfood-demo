INSERT INTO "public"."script" ("id", "created_at", "query", "response", "notice", "added") VALUES ('1000', '2025-09-12 21:34:17.714953+00', '\d', 'Did not find any relations.', 'We''re starting with the empty default, unsharded database.', null), ('2000', '2025-09-12 22:03:49.229311+00', 'CREATE TABLE small_table (num INTEGER);', 'CREATE TABLE', '"small_table" now exists in the default tablegroup, which is not sharded.', '{"default.small_table"}'), ('2500', '2025-09-12 22:05:24.689707+00', 'INSERT INTO small_table VALUES (1), (2), (3);', 'INSERT 0 3', null, null), ('3000', '2025-09-12 21:34:51.59501+00', 'CREATE TABLEGROUP users LOCATION ''us-west-1, us-east-1, us-central-1'';', 'CREATE TABLEGROUP', '"users" is a new TableGroup (sharded set of tables) with 3 shards, in the specified regions.', '{"users:3"}'), ('3500', '2025-09-15 16:56:26.47164+00', 'SET default_tablegroup = users;', 'SET', 'Let''s use this new tablegroup we just created.', null), ('4000', '2025-09-15 14:46:43.637982+00', 'CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, email TEXT) TABLEGROUP users;', 'CREATE TABLE', 'Creates a new sharded table "users." This table is sharded by its primary key, "id."', '{"users.users"}'), ('6000', '2025-09-15 16:53:40.724571+00', 'INSERT INTO users VALUES (...5 billion rows...);', 'INSERT 0 5000000000', '5 billion rows?! No problem for Multigres.', null), ('6500', '2025-09-15 19:02:57.910373+00', 'SELECT username FROM users WHERE id = 1;', ' username 
----------
 cuong
(1 row)', 'Multigres efficiently routes this query to the shard containing the user with id = 1. This is also a fast primary key lookup.', null), ('6501', '2025-09-15 19:08:44.861089+00', 'SELECT id FROM users WHERE username = ''cuong'';', 'id 
----
  1
(1 row)', 'This query will hit ALL shards. This is because Multigres has no mapping between usernames and shards. (Even worse, it''s a full table scan!)', null), ('7000', '2025-09-15 18:43:16.613441+00', 'CREATE UNIQUE LOOKUP INDEX users_username_idx ON users (username) TABLESPACE users;', 'CREATE INDEX', 'This is *STRAWMAN* SQL syntax for creating a secondary index that can be used by Multigres for finding the appropriate shard for the given username.', null), ('8000', '2025-09-15 19:18:44.735801+00', 'SELECT id FROM users WHERE username = ''cuong'';', 'id 
----
  1
(1 row)', 'The lookup index optimizes this query, so that it accesses the single shard that contains the user with the given username. ', null), ('10000', '2025-09-15 16:49:20.550657+00', 'CREATE TABLE addresses (user_id INTEGER REFERENCES users(id), address TEXT) TABLEGROUP users;', 'CREATE TABLE', 'Creates a new sharded table "addresses", which has a foreign key referencing users.id. Based on this foreign key relationship, Multigres infers that addresses rows can be colocated with users rows based on user_id.', '{"users.addresses"}'), ('12000', '2025-09-15 16:54:48.950885+00', 'INSERT INTO addresses VALUES (...5 billion rows...);', 'INSERT 0 5000000000', 'Now we have 5 billion rows in users and addresses.', null), ('13000', '2025-09-15 18:46:30.008473+00', 'SELECT users.id AS user_id, users.username AS username, addresses.address AS address FROM users INNER JOIN addresses ON (users.id = addresses.user_id) WHERE users.username = ''cuong'';', ' user_id | username |      address       
---------+----------+-------------------
       1 | cuong    | London SW1A 1AA, UK
(1 row)', 'The lookup index allows this query to access just one shard, because it enables efficient mapping from username to shard. The foreign key relationship lets Multigres know that joins based on user_id can stay within the same shard.', null);